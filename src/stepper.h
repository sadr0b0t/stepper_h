/**
 * stepper.h
 *
 * Библиотека управления шаговыми моторами, подключенными через интерфейс
 * драйвера "step-dir".
 *
 * LGPLv3, 2014-2024
 *
 * @author Антон Моисеев 1i7.livejournal.com
 */


#ifndef STEPPER_H
#define STEPPER_H

#define NO_PIN -1

#include "stddef.h"

/**
 * Стратегия определения границы движения координаты в одном из направлений:
 * - CONST: значение координаты задается константой в настройках мотора (min/max _pos)
 * - INF: не органичивать движение координаты в этом направлении (значение min/max _pos игнорируется,
 *       концевой датчик, если подключен, обрабатывается в любом случае)
 */
typedef enum {CONST, INF} end_strategy_t;

/**
 * Режим цикла вращения мотора
 */
typedef enum {
    /** Режим калибровки выключен */
    NONE,
    
    /** Калибровка начальной позиции (сбрасывать current_pos в min_pos при каждом шаге) */
    CALIBRATE_START_MIN_POS,
    
    /** Калибровка границ рабочей области (устанавливать max_pos в current_pos при каждом шаге) */
    CALIBRATE_BOUNDS_MAX_POS
} calibrate_mode_t;

/**
 * Статус мотора в цикле вращения: ожидает запуска, запущен, завершил вращение
 */
typedef enum {
    /** Ожидает запуска (выполнен метод prepare_xxx) */
    STEPPER_STATUS_IDLE,
    
    /** Вращается */
    STEPPER_STATUS_RUNNING,
    
    /** Завершил вращение или не начинал и не готовился к нему (метод prepare_xxx не вызывался) */
    STEPPER_STATUS_FINISHED
} stepper_status_t;

/**
 * Побитовые флаги ошибок мотора в цикле вращения (для мотора может быть
 * одновременно установлено несколько флагов).
 */
typedef enum {
    /** С мотором всё ок */
    STEPPER_ERROR_NONE = 0,
    
    /** Завершил вращение из-за достижения виртуальной нижней границы */
    STEPPER_ERROR_SOFT_END_MIN = 0x1,
    
    /** Завершил вращение из-за достижения виртуальной верхней границы */
    STEPPER_ERROR_SOFT_END_MAX = 0x2,
    
    /** Завершил вращение из-за срабатывания концевого датчика нижней границы */
    STEPPER_ERROR_HARD_END_MIN = 0x4,
    
    /** Завершил вращение из-за срабатывания концевого датчика верхней границы */
    STEPPER_ERROR_HARD_END_MAX = 0x8,
    
    /** Слишком маленькая задержка между двумя импульсами для шага */
    STEPPER_ERROR_STEP_DELAY_SMALL = 0x10
} stepper_error_flags;

/**
 * Структура - шаговый двигатель.
 */
typedef struct {
    /**
     * Имя шагового мотора (один символ: X, Y, Z и т.п.)
     */
    char name;
    
    /*************************************************************/
    /* Подключение мотора к драйверу step-dir */
    /*************************************************************/
    
    /* Информация о подключение через драйвер Step-dir */
    
    /**
     * Подача периодического импульса HIGH/LOW будет вращать мотор
     */
    int pin_step;
    
    /**
     * Направление вращения
     * 1 (HIGH): в одну сторону
     * 0 (LOW): в другую
     *
     * Для движения в сторону увеличения значения виртуальной координаты:
     * при dir_inv=1: запись 1 (HIGH) в pin_dir
     * при dir_inv=-1: запись 0 (LOW) в pin_dir
     */
    int pin_dir;
    
    /**
     * Вкл (0)/выкл (1) мотор
     * -1 (NO_PIN): выход не подключен
     */
    int pin_en;
    
    /*************************************************************/
    /* Концевые датчики */
    /*************************************************************/
    
    /**
     * Датчик на конце минимального положения текущей координаты;
     * -1 (NO_PIN): датчик не подключен
     */
    int pin_min;
    
    /**
     * Датчик на конце максимального положения текущей координаты;
     * -1 (NO_PIN): датчик не подключен
     */
    int pin_max;
    
    /*************************************************************/
    /* Настройки подключения - характеристики мотора, драйвера и привода */
    /*************************************************************/
    
    /**
     * Инверсия направления вращения.
     *
     * Для движения в сторону увеличения значения виртуальной координаты:
     * при dir_inv=1: запись 1 (HIGH) в pin_dir
     * при dir_inv=-1: запись 0 (LOW) в pin_dir
     */
    int dir_inv;
    
    /**
     * Минимальная задержка между импульсами step, микросекунды
     * (для движения с максимальной скоростью).
     * 
     * для 32-битного знакового целого:
     *   макс задержка=2^31=2147483648 микросекунд=2147483 миллисекунд=2147 секунды=35 минут
     * для 32-битного беззнакового целого:
     *   макс задержка=2^32=4294967296 микросекунд=4294967 миллисекунд=4294 секунды=71 минута=~1 час
     * 
     * итого 32 бит: оба варианта - более, чем достаточно
     * 
     * для 16-битного знакового целого:
     *   макс задержка=2^15=32768 микросекунд=33 миллисекунды - с натягом норм, но на грани (1/30 макс скрости)
     * для 16-битного беззнакового целого:
     *   макс задержка=2^16=65536 микросекунд=65 миллисекунд - не сильно лучше
     * 
     * итого 16 бит: задержки не подходят.
     * 
     * В PIC32/ChipKIT int и long - 32 бит.
     * В AVR/Arduino long - 32 бит, int - 16 бит.
     * 
     * итого: нам нужны 32 бит, для всех платформ (PIC32/ChipKIT, AVR/Arduino) это long.
     */
    unsigned long min_step_delay;
    
    /**
     * Расстояние, проходимое координатой за один шаг мотора,
     * базовая единица измерения мотора.
     * 
     * На основе значения distance_per_step счетчик шагов вычисляет
     * текущее положение рабочей координаты current_pos.
     * 
     * Единица измерения выбирается в зависимости от задачи и свойств
     * передаточного механизма (рекомендуется считать за нанометры).
     * 
     * для 32-битного беззнакового целого:
     *   макс расстояние/шаг = 2^32 = 4294967296 нанометров = 4294967 микрометров = 4294 миллиметров = 4 метра
     * 
     * итого 32 бит: вполне достаточно
     * 
     * для 16-битного беззнакового целого:
     *   макс расстояние/шаг = 2^16 = 65536 нанометров = 65 микрометра
     * 
     * итого 16 бит: в ряде ситуаций приемлемо, но уже не достаточно:
     * например, для шкива 3д-принтера на моторе без делителя 1 шаг может
     * быть уже 200 микрометров, т.е. не вмещаться в 16 бит.
     * 
     * В PIC32/ChipKIT int и long - 32 бит.
     * В AVR/Arduino long - 32 бит, int - 16 бит.
     * 
     * итого: нам нужны 32 бит, для всех платформ (PIC32/ChipKIT, AVR/Arduino) это long.
     */
    unsigned long distance_per_step;
    
    /*************************************************************/
    /* Характеристики рабочей области */
    /*************************************************************/
    
    /**
     * Стратегия определения конечного положения для минимальной позиции координаты:
     * CONST/INF
     */
    end_strategy_t min_end_strategy;
    
    /**
     * Стратегия определения конечного положения для максимальной позиции координаты:
     * CONST/INF
     */
    end_strategy_t max_end_strategy;
    
    /**
     * Минимальное значение положения координаты, базовая единица измерения мотора
     */
    long long min_pos;
    
    /**
     * Максимальное значение положения координаты, базовая единица измерения мотора
     */
    long long max_pos;
    
    /*************************************************************/
    /* Информация о движении координаты, подключенной к мотору;  */
    /* обновляется динамически в процессе вращения двигателя.    */
    /*************************************************************/
    
    /**
     * Текущее положение координаты, базовая единица измерения мотора.
     *
     * Вычисляется и обновляется программно счетчиком шагов
     * на основе значения distance_per_step.
     * 
     * При dir=1 координата возрастает, при dir=0 координата убывает.
     * 
     * Единица измерения выбирается в зависимости от задачи и свойств
     * передаточного механизма (проще всего считать за нанометры).
     * 
     * Тип данных curren_pos, min_pos и max_pos - long long (int64_t),
     * 64-битное знаковое целое.
     * 
     * Для 64-битного значения current_pos размеры рабочей области
     * с базовой единицей нанометры:
     *   2^63=9223372036854776000 нанометров /1000/1000/1000 =
     *   9223372037 метров /1000 = 9223372км (9 миллионов км).
     * в обе стороны от -9млн км до 9млн км, всего 18млн км (1/3 пути до Марса)
     * 
     * 64-битные типы данных не поддерживаются аппаратно на 32-битных
     * (тем более, на 16-битных) контроллерах, но они реализованы на уровне
     * компилятора и библиотеки libc (как минимум, для платформ ChipKIT и Arduino).
     * Они могу работать чуть медленнее, чем "родные" (на 32-битных контроллерах)
     * 32-битные переменные long, но потеря производительности по факту
     * оказывается не существенной даже в критических частях кода
     * (сравнение с точностью до микросекунд не показало разницы).
     * 
     * При этом использование 64-битных значений фактически позволяет
     * не задумываться о максимальных границах рабочей области.
     * 
     * Для 32хбитного значения current_pos размеры рабочей области были бы:
     * 
     * - Если брать базовую единицу измерения за нанометры (1/1000 микрометра),
     * то диапазон значений для рабочей области будет от нуля в одну сторону:
     *   2^31=2147483648-1 нанометров/1000/1000/1000=2.15метра
     * в обе строны: [-2.15м, 2.15м], т.е. всего 4.3 метра.
     * 
     * - Для базовой единицы микрометр (микрон) рабочая область
     * от -2.15км до 2.15км, всего 4.3км.
     * 
     * Вариант размера рабочей области с базовой идиницей микрометры тоже более, чем
     * приемлем, но размер шага для настольных станков (хотя они на уровне механики
     * могут не поддерживать такую точность) математически часто предполагает доли
     * микрон (6.15мкм, 7.5мкм и т.п.), поэтому в качестве целевой единицы измерения
     * рекомендуется ориентироваться на целочисленные нанометры.
     */
    long long current_pos;
    
    /** Информация о цикле вращения шагового двигателя. */
    
    /**
      * Статус мотора в цикле вращения: ожидает запуска, запущен, завершил вращение.
      * Начальное значение: STEPPER_STATUS_FINISHED
      */
    stepper_status_t status = STEPPER_STATUS_FINISHED;
    
    /** Побитовые флаги ошибок мотора в цикле вращения (для мотора может быть
      * одновременно установлено несколько флогов).
      * Варианты ошибок перечислены в stepper_error_flags:
      *   выход за виртуальные границы, срабатывание концевых датчиков,
      *   слишком маленькая задержка между импульсами шага.
      * Начальное значение: STEPPER_ERROR_NONE
      */
    int error = STEPPER_ERROR_NONE;
} stepper;

/**
 * Глобальные ошибки цикла вращения моторов
 */
typedef enum {
    /** Ошибок нет */
    CYCLE_ERROR_NONE = 0,
    
    /**
     * Хотябы у одного из моторов, добавленных в список вращения,
     * минимальная задержка между шагами не вмещает 3 периода таймера
     * (следует проверить настройки мотора - значение step_delay или
     * настройки частоты таймера цикла stepper_configure_timer).
     */
    CYCLE_ERROR_TIMER_PERIOD_TOO_LONG,
    
    /**
     * Период таймера некратен минимальной задержке между шагами
     * одного из моторов. Это может привести к тому, что при движении
     * на максимальной скорости минимальная задержка меджу шагами
     * не будет соблюдаться, поэтому просто запретим такие комбинации:
     * см: https://github.com/1i7/stepper_h/issues/6
     */
    CYCLE_ERROR_TIMER_PERIOD_ALIQUANT_STEP_DELAY,
    
    /**
     * Проблема с мотором: выход за границы, некорректная задержка между
     * шагами или что-то еще. Подробности см в статусе мотора.
     */
    CYCLE_ERROR_MOTOR_ERROR,
    
    /**
     * Превышено максимальное время выполнения обработчика
     * события от таймера
     */
    CYCLE_ERROR_HANDLER_TIMING_EXCEEDED
} stepper_cycle_error_t;

typedef enum {
    /** Не менять текущее значение (при передаче параметра в настройки) */
    DONT_CHANGE,
    
    /** Игнорировать проблему, продолжать выполнение */
    IGNORE,
    
    /**
     * Попытаться исправить проблему (например, установить ближайшее корректное значение)
     * и продолжить выполнение
     */
    FIX,
    
    /** Остановить мотор, продолжить вращение остальных моторов */
    STOP_MOTOR,
    
    /** Завершить выполнение всего цикла - остановить все моторы */
    CANCEL_CYCLE
} error_handle_strategy_t;

/**
 * Инициализировать шаговый мотор необходимыми значениями.
 * 
 * @param smotor
 * @param name - Имя шагового мотора (один символ: X, Y, Z и т.п.)
 * @param pin_step Подача периодического импульса HIGH/LOW будет вращать мотор
 *     (шаг происходит по фронту HIGH > LOW)
 * @param pin_dir - Направление вращения
 *     1 (HIGH): в одну сторону
 *     0 (LOW): в другую
 *
 *     Для движения вправо (в сторону увеличения значения виртуальной координаты):
 *     при invert_dir==false: запись 1 (HIGH) в pin_dir
 *     при invert_dir==true: запись 0 (LOW) в pin_dir
 * 
 * @param pin_en - вкл (0)/выкл (1) мотор
 *     -1 (NO_PIN): выход не подключен
 * @param invert_dir - Инверсия направления вращения
 *     true: инвертировать направление вращения
 *     false: не инвертировать
 * @param min_step_delay - Минимальная задержка между импульсами, микросекунды
 *     (для движения с максимальной скоростью)
 * @param distance_per_step - Расстояние, проходимое координатой за шаг,
 *     базовая единица измерения мотора.
 *     
 *     На основе значения distance_per_step счетчик шагов вычисляет
 *     текущее положение рабочей координаты current_pos.
 * 
 *     Единица измерения выбирается в зависимости от задачи и свойств
 *     передаточного механизма (рекомендуется считать за нанометры).
 */
void init_stepper(stepper* smotor, char name,
        int pin_step, int pin_dir, int pin_en,
        bool invert_dir, unsigned long min_step_delay,
        unsigned long distance_per_step);

/**
 * Задать настройки границ рабочей области для шагового мотора.
 * 
 * Примеры:
 * 1) область с заранее известными границами:
 *   init_stepper_ends(&sm_z, NO_PIN, NO_PIN, CONST, CONST, 0, 100000);
 * 
 * Движение влево ограничено значением min_pos, движение вправо ограничено значением max_pos
 * (min_pos<=curr_pos<=max_pos).
 * 
 * При калибровке начальной позиции мотора CALIBRATE_START_MIN_POS
 * текущее положение мотора curr_pos сбрасывается в значение min_pos (curr_pos=min_pos)
 * на каждом шаге.
 *
 * При калибровке ширины рабочей области CALIBRATE_BOUNDS_MAX_POS
 * текущее положение мотора curr_pos задает значение max_pos (max_pos=curr_pos)
 * на каждом шаге.
 *
 * 2) область с заранее известной позицией min_pos, значение max_pos не ограничено:
 *   init_stepper_ends(&sm_z, NO_PIN, NO_PIN, CONST, INF, 0, 100000);
 *
 * Движение влево ограничено начальной позицией min_pos (curr_pos не может стать меньше,
 * чем min_pos), движение вправо ничем не ограничено (curr_pos>=min_pos).
 * 
 * @param smotor
 * @param pin_min - номер пина для концевого датчика левой границы
 * @param pin_max - номер пина для концевого датчика правой границы
 * @param min_end_strategy - тип левой виртуальной границы:
 *     CONST - константа, фиксированное минимальное значение координаты
 *     INF - ограничения нет
 * @param max_end_strategy - тип правой виртуальной границы:
 *     CONST - константа, фиксированное максимальное значение координаты
 *     INF - ограничения нет
 * @param min_pos - минимальное значение координаты (для min_end_strategy=CONST)
 * @param max_pos - максимальное значение координаты (для max_end_strategy=CONST)
 */
void init_stepper_ends(stepper* smotor,
        int pin_min, int pin_max,
        end_strategy_t min_end_strategy, end_strategy_t max_end_strategy,
        long long min_pos, long long max_pos);

/**
 * Подготовить мотор к запуску ограниченной серии шагов - задать нужное количество
 * шагов, направление и задержку между шагами для регулирования скорости (0 для максимальной скорости).
 * 
 * @param step_count - количество шагов
 * @param dir - направление вращения: 1 - вращать вперед, -1 - назад, 0 - стоять на месте.
 * @param step_delay - задержка между двумя шагами, микросекунды (0 для максимальной скорости)
 * @param calibrate_mode - режим калибровки
 *     NONE: режим калибровки выключен - останавливать вращение при выходе за виртуальные границы
 *           рабочей области [min_pos, max_pos] (аппаратные проверяются ВСЕГДА);
 *     CALIBRATE_START_MIN_POS: установка начальной позиции (сбрасывать current_pos в min_pos при каждом шаге);
 *     CALIBRATE_BOUNDS_MAX_POS: установка размеров рабочей области (сбрасывать max_pos в current_pos при каждом шаге)
 */
void prepare_steps(stepper *smotor, unsigned long step_count, int dir, unsigned long step_delay, calibrate_mode_t calibrate_mode=NONE);

/**
 * Подготовить мотор к запуску на беспрерывное вращение - задать направление и задержку между
 * шагами для регулирования скорости (0 для максимальной скорости).
 *
 * Мотор будет вращаться до тех пор, пока не будет вручную остановлен вызовом finish_stepper_cycle()
 *
 * @param dir - направление вращения: 1 - вращать вперед, -1 - назад, 0 - стоять на месте.
 * @param step_delay - задержка между двумя шагами, микросекунды (0 для максимальной скорости).
 * @param calibrate_mode - режим калибровки
 *     NONE: режим калибровки выключен - останавливать вращение при выходе за виртуальные границы
 *           рабочей области [min_pos, max_pos] (аппаратные проверяются ВСЕГДА);
 *     CALIBRATE_START_MIN_POS: установка начальной позиции (сбрасывать current_pos в min_pos при каждом шаге);
 *     CALIBRATE_BOUNDS_MAX_POS: установка размеров рабочей области (сбрасывать max_pos в current_pos при каждом шаге)
 */
void prepare_whirl(stepper *smotor, int dir, unsigned long step_delay, calibrate_mode_t calibrate_mode=NONE);

/**
 * Подготовить мотор к запуску ограниченной серии шагов с переменной скоростью - задержки на каждом
 * шаге вычисляются заранее, передаются в буфере delay_buffer.
 * 
 * Масштабирование шага позволяет экономить место в буфере delay_buffer, жертвуя точностью
 * (минимальной длиной шага в цикле); если цикл содержит серии шагов с одинаковой задержкой,
 * реальная точность не пострадает. Буфер delay_buffer содержит временные задержки перед каждым следующим шагом.
 * Можно использовать одну и ту же задержку (один элемент буфера) для нескольких последовательных шагов
 * при помощи параметра step_count (масштаб).
 * 
 * При step_count=1 на каждый элемент буфера delay_buffer ("виртуальный" шаг) мотор будет делать
 *     один реальный (аппаратный) шаг из delay_buffer.
 * При step_count=2 на каждый элемент буфера delay_buffer (виртуальный шаг) мотор будет делать
 *     два реальных (аппаратных) шага с одной и той же задержкой из delay_buffer.
 * При step_count=3 на каждый элемент буфера delay_buffer (виртуальный шаг) мотор будет делать
 *     три реальных (аппаратных) шага с одной и той же задержкой из delay_buffer.
 * 
 * Допустим, в delay_buffer 2 элемента (2 виртуальных шага):
 *     delay_buffer[0]=1000
 *     delay_buffer[1]=2000
 * параметр step_count=3
 * 
 * Мотор сделает 3 аппаратных шага с задержкой delay_buffer[0]=1000 мкс перед каждым шагом и
 * 3 аппаратных шага с задержкой delay_buffer[1]=2000мкс. Всего 2*3=6 аппаратных шагов,
 * время на все шаги = 1000*3+2000*3=3000+6000=9000мкс
 * 
 * Значение параметра buf_size указываем 2 (количество элементов в буфере delay_buffer).
 *
 * Аналогичный результат можно достигнуть с delay_buffer[6]
 *     delay_buffer[0]=1000
 *     delay_buffer[1]=1000
 *     delay_buffer[2]=1000
 *     delay_buffer[3]=2000
 *     delay_buffer[4]=2000
 *     delay_buffer[5]=2000
 * step_count=1, buf_size=6
 *
 * Количество аппаратных шагов можно вычислять как buf_size*step_count.
 * 
 * @param buf_size - количество элементов в буфере delay_buffer (количество виртуальных шагов)
 * @param delay_buffer - массив задержек перед каждым следующим шагом, микросекунды
 * @param step_count - масштабирование шага - количество аппаратных шагов мотора в одном
 *     виртуальном шаге.
 *     Значение по умолчанию step_count=1: виртуальные шаги соответствуют аппаратным.
 * @param dir - направление вращения: 1 - вращать вперед, -1 - назад, 0 - стоять на месте.
 *     Значение по умолчанию dir=1.
 */
void prepare_simple_buffered_steps(stepper *smotor, int buf_size, unsigned long* delay_buffer, unsigned long step_count=1, int dir=1);

/**
 * Подготовить серию шагов с переменной скоростью. Для каждой подсерии задаётся
 * количество шагов, направление вращения и задержка между шагами - соответствующие элементы
 * массивов step_buffer, dir_buffer, delay_buffer.
 * 
 * Массивы step_buffer, dir_buffer и delay_buffer должны существовать и не меняться до завершения
 * цикла вращения (рекомендуется объявлять их как глобальные переменные модуля или
 * как локальные переменные внутри функции с модификатором static).
 * 
 *   // 
 *   static unsigned long step_buffer[3];
 *   static int dir_buffer[3];
 *   static unsigned long delay_buffer[3];
 * 
 *   // количество шагов в каждой серии
 *   step_buffer[0] = 200*10;
 *   step_buffer[1] = 200*5;
 *   step_buffer[2] = 200*2;
 * 
 *   // направление движения в каждой серии
 *   dir_buffer[0] = 1; // туда
 *   dir_buffer[1] = -1; // обратно
 *   dir_buffer[2] = 1; // туда
 * 
 *   // значения задержек между шагами в каждой серии
 *   delay_buffer[0] = y_step_delay_us; // базовая скорость
 *   delay_buffer[1] = y_step_delay_us*10; // в 10 раз медленнее
 *   delay_buffer[2] = y_step_delay_us*2; // в 2 раза медленнее
 * 
 *   prepare_buffered_steps(&sm_y, 3, step_buffer, dir_buffer, delay_buffer);
 * 
 * @param buf_size - количество серий (количество элементов в массивах step_buffer, dir_buffer, delay_buffer)
 * @param step_buffer - (step count buffer) - массив с количеством шагов для каждой серии.
 *     Должен содержать buf_size элементов.
 * @param dir_buffer - (step direction buffer) - массив с направлениями движения для каждой
 *     из серий.
 *     Варианты значений:
 *        1 - вращение вперед
 *       -1 - вращение назад
 *        0 - стоять на месте (не делать шаг)
 *     Должен содержать buf_size элементов.
 * @param delay_buffer - (step delay buffer) - массив задержек между шагами для каждой из серий, микросекунды.
 *     Должен содержать buf_size элементов.
 */
void prepare_buffered_steps(stepper *smotor, int buf_size, unsigned long* step_buffer, int* dir_buffer, unsigned long* delay_buffer);

/**
 * Подготовить мотор к запуску ограниченной серии шагов с переменной скоростью - задать нужное количество
 * шагов, направление и указатель на функцию, вычисляющую задержку перед каждым шагом для регулирования скорости.
 * 
 * @param step_count - количество шагов.
 * @param dir - направление вращения: 1 - вращать вперед, -1 - назад, 0 - стоять на месте.
 * @param curve_context - указатель на объект, содержащий всю необходимую информацию для вычисления
 *     времени до следующего шага.
 * @param next_step_delay - указатель на функцию, вычисляющую задержку перед следующим шагом, микросекунды.
 */
void prepare_dynamic_steps(stepper *smotor, unsigned long step_count, int dir,
        void* curve_context, unsigned long (*next_step_delay)(unsigned long curr_step, void* curve_context));

/**
 * Подготовить мотор к запуску на беспрерывное вращение с переменной скоростью - задать нужное количество
 * шагов и указатель на функцию, вычисляющую задержку перед каждым шагом для регулирования скорости.
 * 
 * @param dir - направление вращения: 1 - вращать вперед, -1 - назад, 0 - стоять на месте.
 * @param curve_context - указатель на объект, содержащий всю необходимую информацию для вычисления
 *     времени до следующего шага
 * @param next_step_delay - указатель на функцию, вычисляющую задержку перед следующим шагом, микросекунды
 */
void prepare_dynamic_whirl(stepper *smotor, int dir,
        void* curve_context, unsigned long (*next_step_delay)(unsigned long curr_step, void* curve_context));


//////////////////////////////////////////
// Управление циклом

/**
 * Запустить цикл шагов на выполнение - запускаем таймер с
 * обработчиком прерываний отрабатывать подготовленную программу.
 *
 * @return
 *     true - цикл запущен
 *     false - цикл не запущен, т.к. предыдущий цикл еще не завершен
 */
bool stepper_start_cycle();

/**
 * Завершить цикл шагов - остановить таймер, обнулить список моторов.
 */
void stepper_finish_cycle();

/**
 * Поставить вращение на паузу, не прирывая всего цикла
 */
void stepper_pause_cycle();

/**
 * Продолжить вращение, если оно было поставлено на паузу
 */
void stepper_resume_cycle();

/**
 * Текущий статус цикла:
 * true - в процессе выполнения,
 * false - ожидает запуска.
 */
bool stepper_cycle_running();

/**
 * Проверить, на паузе ли цикл:
 * true - цикл на паузе (выполняется)
 * false - цикл не на паузе (выполняется или остановлен).
 */
bool stepper_cycle_paused();

/**
 * Код ошибки цикла.
 * @return статус ошибки из перечисления stepper_cycle_error_t
 *     CYCLE_ERROR_NONE (== 0) - ошибки нет
 *     >0 - код ошибки из перечисления stepper_cycle_error_t
 */
stepper_cycle_error_t stepper_cycle_error();

/**
 * Максимальное время выполнения обработчика прерывания
 * таймера в текущем цикле, микросекунды. Должно быть
 * всегда меньше периода таймера.
 */
unsigned long stepper_cycle_max_time();

/////////////////////////////////////////
// Системные настройки

/**
 * Настроить таймер для шагов.
 * Частота ядра PIC32MX - 80МГц == 80млн операций в секунду.
 * Берем базовый предварительный масштаб таймера
 * (например, TIMER_PRESCALER_1_8), дальше подбираем
 * частоту под нужный период
 * 
 * Example: to set timer clock period to 20ms (50 operations per second == 50Hz)
 * use prescaler 1:64 (0x0060) and period=0x61A8:
 * 80000000/64/50=25000=0x61A8
 * 
 * для периода 1 микросекунда (1млн вызовов в секунду == 1МГц):
 * // (уже подглючивает)
 * 80000000/8/1000000=10=0xA
 *   target_period_us = 1
 *   prescalar = TIMER_PRESCALER_1_8 = 8
 *   period = 10
 * 
 * для периода 5 микросекунд (200тыс вызовов в секунду == 200КГц):
 * 80000000/8/1000000=10
 *   target_period_us = 5
 *   prescalar = TIMER_PRESCALER_1_8 = 8
 *   period = 50
 * 
 * для периода 10 микросекунд (100тыс вызовов в секунду == 100КГц):
 * // ок для движения по линии, совсем не ок для движения по дуге (по 90мкс на acos/asin)
 * 80000000/8/100000=100=0x64
 *   target_period_us = 10
 *   prescalar = TIMER_PRESCALER_1_8 = 8
 *   period = 100
 *
 * для периода 20 микросекунд (50тыс вызовов в секунду == 50КГц):
 * 80000000/8/50000=200
 *   target_period_us = 20
 *   prescalar = TIMER_PRESCALER_1_8 = 8
 *   period = 200
 *
 * для периода 80 микросекунд (12.5тыс вызовов в секунду == 12.5КГц):
 * 80000000/8/12500=200
 *   target_period_us = 80
 *   prescalar = TIMER_PRESCALER_1_8 = 8
 *   period = 800
 *
 * для периода 100 микросекунд (10тыс вызовов в секунду == 10КГц):
 * 80000000/8/10000=1000
 *   target_period_us = 100
 *   prescalar = TIMER_PRESCALER_1_8 = 8
 *   period = 1000
 *
 * для периода 200 микросекунд (5тыс вызовов в секунду == 5КГц):
 * // ок для движения по дуге (по 90мкс на acos/asin)
 * 80000000/8/5000=2000
 *   target_period_us = 200
 *   prescalar = TIMER_PRESCALER_1_8 = 8
 *   period = 2000
 *
 * @param target_period_us - целевой период таймера, микросекунды.
 * @param timer - системный идентификатор таймера (должен поддерживаться аппаратно)
 * @param prescalar - предварительный масштаб таймера
 * @param adjustment - значение корректировки для периода таймера: делитель частоты таймера
 *     после того, как к ней применен предварительный масштаб (prescaler)
 */
void stepper_configure_timer(unsigned long target_period_us, int timer, int prescaler, unsigned int adjustment);

/**
 * Режим отладки: не включать аппаратный таймер при запуске цикла шагов,
 * шаги можно осуществлять вручную серией вызовов _stepper_handle_interrupts.
 * Может быть полезно при тестировании.
 * @param enabled
 *   false: не включать таймер
 *   true: таймер работает в обичном режиме
 */
void stepper_set_timer_enabled(bool enabled);

/**
 * Стратегия реакции на некоторые исключительные ситуации, которые
 * могут произойти во время вращения моторов.
 *
 * @param hard_end_handle - выход за границы по аппаратному концевику.
 *     допустимые значения: STOP_MOTOR/CANCEL_CYCLE
 *     по умолчанию: CANCEL_CYCLE
 * @param soft_end_handle - выход за виртуальные границы.
 *     допустимые значения: STOP_MOTOR/CANCEL_CYCLE
 *     по умолчанию: CANCEL_CYCLE
 * @param small_step_delay_handle - задержка между шагами меньше
 *       минимально допустимой для мотора.
 *     допустимые значения: FIX/STOP_MOTOR/CANCEL_CYCLE
 *     по умолчанию: CANCEL_CYCLE
 * @param cycle_timing_exceed_handle - обработчик прерывания выполняется дольше,
 *       чем период таймера.
 *     допустимые значения: IGNORE/CANCEL_CYCLE
 *     по умолчанию: CANCEL_CYCLE
 */
void stepper_set_error_handle_strategy(
        error_handle_strategy_t hard_end_handle,
        error_handle_strategy_t soft_end_handle,
        error_handle_strategy_t small_step_delay_handle,
        error_handle_strategy_t cycle_timing_exceed_handle);


#endif // STEPPER_H

